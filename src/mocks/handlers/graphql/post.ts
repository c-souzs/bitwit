import { graphql } from 'msw'

const createDataPage = (slug: string) => {
    const coverImage = {
        url: 'https://media.graphassets.com/C7Qrne0qSxuBwyRWLAnZ'
    }
    const author = {
        name: 'Caio Souza', 
        picture: {
            url: 'https://media.graphassets.com/output=format:jpg/resize=height:800,fit:max/C16oaHwoSMGf6FImPL1j'
        }
    }
    const title = `Create data page fake  ${slug}`
    const tags = [...Array(3)].map((_, i) => ({ name: `TEST ${i}` }))
    const date = new Date()
    const createdAt = date.toISOString()
    const content = {
        html: `<p>O React é uma biblioteca JavaScript popular para desenvolvimento de interfaces de usuário em aplicações web. No entanto, gerenciar o estado de uma aplicação com React pode se tornar uma tarefa complexa e difícil de manter à medida que a aplicação cresce em escopo e complexidade. O Redux é uma biblioteca que oferece uma solução eficiente para gerenciamento de estado em aplicações web com React. Com o Redux, é possível centralizar o estado em uma única Store e manter a lógica de negócio separada da interface do usuário, facilitando a manutenção e evolução da aplicação ao longo do tempo. Neste post, vamos explorar os principais conceitos do Redux e como utilizá-lo em conjunto com o React para gerenciar o estado de uma aplicação web de forma eficiente e escalável.<br></p><p><br><strong>Introdução</strong></p><p>O Redux é uma biblioteca para gerenciamento de estado em aplicações web que utiliza o modelo de arquitetura Flux. Ele é baseado em três princípios fundamentais: uma única fonte de verdade (Single Source of Truth), estado somente leitura (State is Read-only) e mudanças feitas através de funções puras (Changes are Made with Pure Functions).</p><p>O princípio de uma única fonte de verdade significa que todo o estado da aplicação é armazenado em uma única Store, o que facilita a visualização e o gerenciamento do estado da aplicação. O estado é imutável, ou seja, ele não pode ser alterado diretamente. Em vez disso, para alterar o estado, é necessário criar uma Action, que é uma descrição de uma mudança a ser realizada no estado da aplicação. As Actions são enviadas para a Store através do Dispatch, que é responsável por propagar a mudança para os Reducers, que são funções puras responsáveis por atualizar o estado de acordo com as Actions recebidas.</p><p>Dessa forma, o Redux garante que o estado seja atualizado de forma previsível e consistente, o que ajuda a reduzir a complexidade e aumentar a qualidade do código. Além disso, como o estado é centralizado, é mais fácil depurar problemas e manter a integridade do estado da aplicação em cenários de concorrência e escalabilidade.</p><pre><code>import { createStore } from &#39;redux&#39;;\r\n\r\n// define um estado inicial\r\nconst initialState = {\r\n  counter: 0\r\n}\r\n\r\n// cria um reducer que atualiza o estado baseado nas actions recebidas\r\nconst counterReducer = (state = initialState, action) =&gt; {\r\n  switch (action.type) {\r\n    case &#39;INCREMENT&#39;:\r\n      return {\r\n        ...state,\r\n        counter: state.counter + 1\r\n      }\r\n    case &#39;DECREMENT&#39;:\r\n      return {\r\n        ...state,\r\n        counter: state.counter - 1\r\n      }\r\n    default:\r\n      return state\r\n  }\r\n}\r\n\r\n// cria a store passando o reducer como argumento\r\nconst store = createStore(counterReducer)\r\n\r\n// dispara uma action para incrementar o contador\r\nstore.dispatch({ type: &#39;INCREMENT&#39; })\r\n\r\n// imprime o estado atual\r\nconsole.log(store.getState()) // { counter: 1 }</code></pre><p>⁠<strong>Arquitetura Flux<br><br></strong>A arquitetura Flux é o modelo que o Redux segue para gerenciamento de estado em aplicações web. Ela foi desenvolvida pelo Facebook para lidar com a complexidade do gerenciamento de estado em aplicações com React. A arquitetura Flux é baseada em quatro componentes principais: Dispatcher, Store, Action e View.</p><p>O Dispatcher é o componente responsável por receber todas as Actions e encaminhá-las para os Stores registrados. Cada Store é responsável por gerenciar um determinado tipo de dado da aplicação, e contém toda a lógica para atualização do estado de acordo com as Actions recebidas. As Actions são objetos que contêm informações sobre as mudanças que devem ser realizadas no estado da aplicação, e são geradas a partir das interações do usuário com a interface da aplicação. Por fim, a View é o componente responsável por renderizar a interface da aplicação com base no estado atual.</p><p>A arquitetura Flux permite uma separação clara entre a lógica de negócio e a interface do usuário, o que facilita a manutenção e evolução da aplicação ao longo do tempo. Com a utilização do Redux, é possível implementar essa arquitetura de forma mais eficiente e escalável em aplicações web com React.</p><pre><code>// Actions\r\nconst ADD_TODO = &#39;ADD_TODO&#39;;\r\n\r\nfunction addTodoAction(text) {\r\n  return {\r\n    type: ADD_TODO,\r\n    payload: {\r\n      text,\r\n      completed: false,\r\n    },\r\n  };\r\n}\r\n\r\n// Reducers\r\nfunction todosReducer(state = [], action) {\r\n  switch (action.type) {\r\n    case ADD_TODO:\r\n      return [\r\n        ...state,\r\n        action.payload,\r\n      ];\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\n// Store\r\nconst store = createStore(todosReducer);\r\n\r\n// View\r\nfunction TodoList() {\r\n  const todos = useSelector(state =&gt; state);\r\n  const dispatch = useDispatch();\r\n\r\n  function handleAddTodo() {\r\n    dispatch(addTodoAction(&#39;New Todo&#39;));\r\n  }\r\n\r\n  return (\r\n    &lt;div&gt;\r\n      &lt;button onClick={handleAddTodo}&gt;Add Todo&lt;/button&gt;\r\n      {todos.map(todo =&gt; (\r\n        &lt;div key={todo.id}&gt;\r\n          &lt;input type=&quot;checkbox&quot; checked={todo.completed} /&gt;\r\n          &lt;span&gt;{todo.text}&lt;/span&gt;\r\n        &lt;/div&gt;\r\n      ))}\r\n    &lt;/div&gt;\r\n  );\r\n}\r\n</code></pre><p><strong>Store e Reducers</strong></p><p>Na arquitetura Flux, as Stores são responsáveis por gerenciar o estado da aplicação. No Redux, a Store é a única fonte de verdade para o estado da aplicação. A Store é criada a partir da função createStore() do Redux, e recebe como parâmetro um Reducer, que é uma função pura que recebe o estado atual e uma Action, e retorna o novo estado atualizado.</p><p>Os Reducers são responsáveis por atualizar o estado da aplicação de acordo com as Actions recebidas pela Store. Cada Reducer é responsável por atualizar um determinado pedaço do estado da aplicação, de forma independente. A cada Action recebida pela Store, o Reducer correspondente é chamado para atualizar o estado, que é então armazenado na Store.</p><p>Os Reducers devem ser funções puras, ou seja, não devem modificar o estado atual diretamente. Em vez disso, devem criar uma cópia do estado atual, realizar as mudanças necessárias e retornar a nova cópia do estado atualizado. Dessa forma, é possível garantir que as mudanças no estado sejam previsíveis e consistentes, o que ajuda a reduzir a complexidade e aumentar a qualidade do código.</p><p>Com a utilização de Reducers, é possível criar uma estrutura de dados hierárquica para o estado da aplicação, o que ajuda a separar a lógica de negócio em diferentes partes da aplicação. Essa abordagem facilita a manutenção e evolução da aplicação ao longo do tempo, além de ajudar a lidar com cenários de concorrência e escalabilidade.<br><br><strong>Actions e Dispatch<br><br></strong>As Actions são objetos que descrevem uma mudança a ser realizada no estado da aplicação. Elas são geradas a partir das interações do usuário com a interface da aplicação, e são enviadas para a Store por meio do Dispatcher. O Dispatcher é responsável por encaminhar cada Action para o Reducer correspondente na Store, que então atualiza o estado da aplicação de acordo com as mudanças descritas na Action.</p><p>Para enviar uma Action para a Store, é necessário utilizar a função dispatch() do Redux. A função dispatch() recebe como parâmetro a Action que será enviada para a Store. Essa abordagem garante que as mudanças no estado da aplicação sejam realizadas de forma previsível e consistente, seguindo as regras definidas pelos Reducers.</p><p>Com a utilização de Actions e Dispatch, é possível descrever todas as mudanças de estado da aplicação de forma clara e declarativa, o que facilita o entendimento do código e a colaboração entre diferentes membros da equipe de desenvolvimento. Além disso, essa abordagem ajuda a lidar com cenários de concorrência e escalabilidade, garantindo que as mudanças no estado da aplicação sejam tratadas de forma correta e consistente em todos os casos.</p><pre><code>import { createStore } from &#39;redux&#39;;\r\n\r\n// Define o estado inicial\r\nconst initialState = {\r\n  count: 0\r\n};\r\n\r\n// Define o reducer\r\nfunction counterReducer(state = initialState, action) {\r\n  switch (action.type) {\r\n    case &#39;INCREMENT&#39;:\r\n      return { ...state, count: state.count + 1 };\r\n    case &#39;DECREMENT&#39;:\r\n      return { ...state, count: state.count - 1 };\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\n// Cria a Store com o Reducer\r\nconst store = createStore(counterReducer);\r\n\r\n// Escuta mudanças na Store\r\nstore.subscribe(() =&gt; console.log(store.getState()));\r\n\r\n// Dispara uma Action para a Store\r\nstore.dispatch({ type: &#39;INCREMENT&#39; }); // { count: 1 }\r\nstore.dispatch({ type: &#39;INCREMENT&#39; }); // { count: 2 }\r\nstore.dispatch({ type: &#39;DECREMENT&#39; }); // { count: 1 }\r\n</code></pre><p>⁠Em resumo, o Redux é uma biblioteca que oferece uma solução para o gerenciamento de estado em aplicações JavaScript. Baseado na arquitetura Flux, o Redux utiliza uma Store centralizada e Reducers para gerenciar o estado da aplicação de forma previsível e consistente. Além disso, o uso de Actions e Dispatch ajuda a descrever de forma declarativa as mudanças no estado da aplicação, o que facilita o entendimento do código e a manutenção da aplicação ao longo do tempo. A utilização do Redux pode ser especialmente útil em aplicações com grande quantidade de dados ou com cenários de concorrência e escalabilidade, ajudando a reduzir a complexidade do código e aumentar a qualidade da aplicação. Para mais código acesse <a target='_blank' title=\"https://github.com/souzzs\" href=\"https://github.com/souzzs\">Souzzs Github</a><br><br>Post gerado por uma inteligência artificial.</p>`
    }
    
    return {
        coverImage, author, title, tags, createdAt, content
    }
}

const handlerPostBySlugGet = graphql.query('getPostBySlug', (req, res, ctx) => {

    const { slug } = req.variables

    const post = createDataPage(slug)

    return res(
        ctx.data({
            post
        })
    )
})

export const handlersPostSlug = [
    handlerPostBySlugGet
]